#showme {<aef>Loading: <faa>prompt.tt}

/*  Setup Status bar display and prompt triggers {{{
	
	You can customize the prompt/staus bar here, however this code is not
	pretty and modifying it will take a fair bit of work.  I have tried to
	modualrize and profusely comment this code to make it as comprehensable
	as I can.

	Note, that most of this gets executed for EVERY prompt.  For this reason
	I felt that speed/efficiency was more important than transparancy.

	As a general rule, try to put subunits into prompt/subStrings.tt
	Also try to unvar any non-persistent variables as soon as possible.

This is generally what it would look like with most everything maxed/true:	
[==============================================================================]
[SAFE][N E S W U D Nw Ne Sw Se]  [LAGED][CASTING][100%][1234x,1234y][g F][18:06]
[99% LongCharName][100%][M:9999st][                   ][249 250 245 132 106 114]
[ScSsBlP*ArShSaStFsLsAw AaHsEhDg][PaBlSiSlWbPoPlCuFfWk][LvPdUwLwSeDnDiDm HiSnSh]
<2750hp 3500sp 2750st> [+2700 -1250 =____] [H][T][Enc][PANIC][Rx#][BoT][Mail][I]

Other tags: [Search][Dig][Q][B][C][T][SW][S][Q][A][News][TAG!]
(This looks a lot better in CoLoRs!)
 }}} */

/* Dummy values to prevent errors before values are properly set {{{ */
#if {&vitals[] == 0} {
	#var vitals[max][hp] 5000;
	#var vitals[max][sp] 5000;
	#var vitals[max][st] 5000;
	#var gtime[regen]   100;
	#var gtime[time]      0;
	#var _exitsC        {N E S W U D Nw Ne Sw Se};
}
/* }}} */

/* Reserve area for the status bar, and set the prompt's format */
#split  {$prefs[split][top]} {$prefs[split][bot]};

/* Extracts mounts stamina and gags the line {{{ */
#act {^(Mount: %dst)} {
	#var mount[stamina]  {%1};
	#var stateChar[mounted] 2;
	#line gag;
}
/* }}} */

/* Only Update Affects Bar On Affects Changes {{{ */
_event_register {affect_change}  {updatePrompt} {_UpdatePromptAffects #nop};
_event_register {affect_refresh} {updatePrompt} {_UpdatePromptAffects #nop};

#alias {_UpdatePromptAffects} {
	#class affBar read core/prompt/affectbar.tt;
	_PromptAffectBar;
	#class affBar kill;
}
/* }}} */

/* Bind to EOR / Prompt Event and Raise prompt_* Events {{{ */
#event {RECEIVED PROMPT}
{
	#var prompt[raw] {%1};
	#var __promptType {Unknown};

	#if {"%1" == "%*<%dhp %dsp %dst> "}
		{#var __promptType {Default};
	};
	#elseif {"%1" == "[C]ontinue [R]edraw [B]ack [E]xit: "}
		{#var __promptType {Continue};
	};
	#elseif {"%1" == "%*({Social|#.*}) "}
		{#var __promptType {Social};
	};
	#elseif {"%1" == "%*(%Shull %Sdir %S %Swind%*"}
		{#var __promptType {Ship};
	};
	
	_event_raise {prompt_pre} {${__promptType}} {%1};
	_prompt${__promptType} {%1};
	_event_raise {prompt_${__promptType}} {%1};
	#if {"${__promptType}" != "Continue" } {
		_event_raise {prompt_post} {${__promptType}} {%1};
	};
	#unvar __promptType;
}

/* Gag extra prompt strings */
#gag {%*<%dhp %dsp %dst> $};
/* }}} */

/* Default Prompt {{{ */
#alias {_promptDefault} {
	#class promptLines read core/prompt/subprompt.tt;
	#regex {%1} {<%dhp %dsp %dst>} {
		#var vitals[o] {$vitals[c]};
		#var vitals[c][hp] {&1};
		#var vitals[c][sp] {&2};
		#var vitals[c][st] {&3};
	};

	#math stateChar[mounted] @std_dec2zero{$stateChar[mounted]};
	#math stateChar[Combat]  @std_dec2zero{$stateChar[Combat]};

	#var stateChar[inSocial] 0;
	#var stateChar[OnShip]   0;

	_calcVitals;

	#var vitals[print] @promptVitalsBar{};	

	_CombatEcho;

	#var promptFlags @promptFlagsBar{};
	#format {prompt[1]} {%-40s%+40s} {$vitals[print]} {$promptFlags};
	#unvar vitals[print];
	#unvar promtFlags;

	_PromptExtrasBar;
	_PromptTop;

	#loop {-$prefs[split][top]} {$prefs[split][bot]} {__pLine} {
		#if {${__pLine} != 0 } {
			#echo { {%.80s} {${__pLine}} } {$prompt[${__pLine}]};
		};
	};
	#unvar __pLine;

	_PromptNavBar;
	_PromptTick;

	#line gag;
	#var stateChar[justLooking] 0;
	#math stateChar[muteLine] @std_dec2zero{$stateClient[muteLine]};
	#class promptLines kill;
}
/* }}} */

/* Hook to Tick Event to Update Prompt Clock {{{ */
_event_register {tick} {promptTick} {_PromptTick #nop};

/* To be called whenever the time is updated */
#alias {_PromptTick} {
	#format prompt[4] {%s%s} {$prompt[b]} {$gtime[print]};
	#echo {{%.80s}{4}} {$prompt[4]};
}
/* }}} */

/* Ship Prompt {{{ */
#alias {_promptShip}
{
	#regex {%1} {%*(%Shull %Sdir %S %Swind} {
		#format prompt[1] 
		{<149><<099>%s<149>hull <099>%s<149>dir<099> %s %s<149>wind}
		{&2} {&3} {&4} {&5} {&6};
	};
	#regex {%1} {%d\%shld} {
		#format prompt[1] {%s <099>%s%a<149>shld>} {$prompt[1]} {&1} {37};
	} {
		#var prompt[1] {${prompt[1]}><099>};
	};
	#var stateChar[OnShip] 1;
	#class promptLines read core/prompt/subprompt.tt;
	#format {prompt[1]} {%-40s} {$prompt[1]};
	#var promptFlags @promptFlagsBar{};
	#format {prompt[1]} {%-40s%+40s} {$prompt[1]} {$promptFlags};
	_PromptTop;

	#loop {-$prefs[split][top]} {$prefs[split][bot]} {__pLine} {
		#if {${__pLine} != 0 } {
			#echo { {%.80s} {${__pLine}} } {$prompt[${__pLine}]};
		};
	};
	#unvar __pLine;

	_PromptNavBar;
	_PromptTick;
	#line gag;
	#class promptLines kill;
}
/* }}} */

/* Social Prompt {{{ */ 
#alias {_promptSocial}
{
	#var stateChar[inSocial] 1;
	#regex {%1} {%*({Social|#.*}) } {
		#format {prompt[1]} {<099>[<148>&2<099>]<098>};
		#if { "&2" != "Social" } {
			#var stateChar[inChatRoom] {&2};
			#replace stateChar[inChatRoom] {#} {};
		} {
			#unvar stateChar[inChatRoom];
		};
	};
	#class promptLines read core/prompt/subprompt.tt;

	#format prompt[1] {%-40s} {$prompt[1]};
	#var promptFlags @promptFlagsBar{};
	#format {prompt[1]} {%-40s%+40s} {$prompt[1]} {$promptFlags};
	_PromptTop;
	#var prompt[3] @blankPrompt{};
	#loop {-$prefs[split][top]} {$prefs[split][bot]} {__pLine} {
		#if {${__pLine} != 0 } {
			#echo { {%.80s} {${__pLine}} } {$prompt[${__pLine}]};
		};
	};
	#unvar __pLine;
	_PromptNavBar;
	_PromptTick;
	#class promptLines kill;
	#line gag;
}
/* }}} */

/* Handle Special "Continue" Prompt {{{ */
#alias {_promptContinue} {
	#nop %1;
	#if {$stateClient[autoContinue]} {
		#line gag;
		#send {continue}
	};
}
/* }}} */

/* Dummy to do nothing on a unknown prompt type {{{ */
#alias {_promptUnknown} {
	#nop %1;
}
/* }}} */
