#nop lib/string.tt
/*
	Author: LokiChaos Â©2009-2016 Released under the ISC License (See doc/license.txt)
*/
#nop CLASS: string;
#nop PROVIDES: lib/string;
#nop REQUIRES: lib/ttext;

#function {string_sanitize} {
	#var result {%0};
	#replace {result} {'} {\047};
}

/*
	Usage: @stringing_esc{ <string> }
	<string> = a string
	Returns: <string> with all non-Alphanum, _, and - escaped.
*/
#function {string_esc} {
	#var result {%0};
	#replace {"} {\\"};
	#script {result} {echo "$(echo "%0" | sed 's/[^-A-Za-z0-9_]/\\&/g')"};
	#var result {$result[1]};
}

/*
	Usage: @stringing_escape{ {<string>} {<pat>;<rep>} [...] }
	<string> = a string
	<pat> = a patter to be replaced
	<rep> = what to replace <pat> with
	Any number of <pat>/<rep> pairs my be given
	This is a genralized pattern replacement function.
	Generally, it is called by another specific-case escape function.
	Returns: <string> will every instance of every <pat> replaced with their corrisponding <rep>
*/
#func {string_escape} {
	beginScope;
	#var result %1;
	#var my.aidx 0;
	#foreach {%0} {my.arg} {
		#math my.aidx {1 + ${my.aidx}};
		#if {${my.aidx} > 1 } {
			#var my.asidx 0;
			#var my.a[2] {};
			#foreach {${my.arg}} {my.argsub} {
				#math my.asidx {1 + ${my.asidx}};
				#var my.a[${my.asidx}] {${my.argsub}};
			};
			#line sub var #replace {result} {${my.a[1]}} {${my.a[2]}};
			#unvar my.a;
		};
	};
	endScope;
};

/* Escape Un-safe for sh/awk/sed*/
/*
	Usage: @stringing_escape_shell{ <string> }
	<string> = a string
	Returns: <string> with all non-Alphanum, _, and - escaped.
*/
#function {string_escape_shell} {
	#var result @string_escape{ {%0} {\';\047} {\";\\"} };
};

/* Escaped URI */
#function {string_escape_uri} {
	#var result @string_escape{ {%0}
	{\{;\0457B} {\};\0457D}
	{\ ;\04520} {\=;\0453D} {\&;\04526}
	{\:;\0453A} {\\\;;\0453B} {\/;\0452F} {\\;\0455C}
	{\<;\0453C} {\>;\0453E} {\[;\0455B} {\];\0455D}
	{\$;\04524}	{\#;\04523} {\|;\0457C} {\^;\0455E}
	{\~;\0457E} {\`;\04560} {\?;\0453F} {\@;\04540}
	};
};

/*
	Usage: @string_dropcomma{ <string> }
	<string> = a string
	Returns: the <string> with commas removed, intended for numbers
	         eg: 1,337 -> 1337
*/
#function {string_dropcomma} {
	#format result {%d} {%0}
}

/*
	Usage: @string_strip{ <string> }
	<string> = a string
	Returns: <string> will all SGR codes, tintin color codes, etc removed
*/
#function {string_strip} {
	#line strip {#var result {%0}};
	#replace result {<%.%.%.>} {};
}

/*
	Usage: @string_len{ <string> }
	<string> = a string
	Returns: the length of <string>
*/
#function {string_len} {
	#format result {%L} {%0};
}

/*
	Usage: @string_trim{ <string> }
	<string> = a string
	Returns: <string> with all leading and trailing spaces stripped
*/
#function {string_trim} {
	#regex {%0} {^{ *}%*{ *}$} {
		#var result {&2};
	};
}

/*
	Usage: @string_toLower{ <string> }
	<string> = a string
	Returns: <string> with all upper case converted to lower
*/
#function {string_toLower} {
	#format result {%l} {%0};
}

/*
	Usage: @string_toUpper{ <string> }
	<string> = a string
	Returns: <string> with all lower case converted to upper
*/
#function {string_toUpper} {
	#format result {%u} {%0};
}

/*
	Usage: @string_tokenize{ <string> }
	<string> = a string
	Returns: a list of the words in <string>, in the order they appear in
*/
#function {string_tokenize} {
	#list result create %0;
}

/*
	Usage: @string_reverse{ <string> }
	<string> = a string
	Returns: <string> mirrored/fliped/reversed
	        e.g.: foobar -> raboof
*/
#function {string_reverse} {
	#format result {%r} {%0};
}

/*
	Usage: @string_substr{ {<string>} {<pos>} {<length>} }
	<pos> = integer position of substring
	<length> = integer length of substring
	Returns: nil or substring of <length> starting at <posistion> in <string>.
*/
#function {string_substr} {
	#regex {%1} {^{.{%2}}{.{%3}}%*} {
		#var result {&2};
	} {
		#var result {};
	};
}

/*
	Usage: @string_contains{ {<stringA>} {<stringB>} }
	<string> = a string
	Returns: 1 if <stringA> appears anywhere in <stringB> else 0.
*/
#function {string_contains} {
	#math result {"%2" == "%*%1%*"};
}

/*
	Usage: @string_containsWord{ {<stringA>} {<stringB>} }
	<string> = a string
	Returns: 1 if <stringA> appears as a word in <stringB> else 0.
*/
#function {string_containsWord} {
	#regex {%2} {{\b%1\b}} {
		#var result 1;
	} {
		#var result 0;
	};
}

/* Verify loading */
#var loadState {1};
/* EOF */
